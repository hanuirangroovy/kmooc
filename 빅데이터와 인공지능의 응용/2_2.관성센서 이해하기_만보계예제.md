# 2주차. 인간 행동 탐지 및 응용➀

## 2-1. 관성센서 이해하기 : 만보계 예제

- 만보계 : 걸음을 탐지하고 걸음의 횟수를 세는 작업 수행
  - 이 작업을 수행하기 위해 가속도계를 활용
- Ideal Acceleration Signal of Walking
  - 스텝을 걸을 때마다 주기적으로 가속이 됐다 감속이 됐다 패턴이 나오면 좋음
  - 스마트폰에 있는 가속도계를 활용하면 이런 패턴은 나오지 않음
  - 스마트폰에 있는 가속도계 활용
    - 가속도계가 삼축 방향의 가속도를 센싱을 하게 되는데 한 축의 가속도 정보를 주는 게 아니라 세 개의 축의 가속정보를 주게 됨
    - 걸음을 걸을 동안 수직 방향의 가속이 제일 크기 때문에 스마트폰을 이 방향으로 들고 있다 생각하면 Y축 방향의 가속이 가장 크게 나타나고 나머지 방향으로의 가속도 조금씩 미세하게나마 나타나게 됨
- 여러가지 스텝을 탐지하기 위한 방법
  - 노이즈한 시그널을 이상적인 시그널로 변환하는 과정을 거쳐 스텝 탑지
  - 이상적인 시그널과 현실적인 시그널 차이
    - 이상적인 시그널
      - 한 축 방향만 있음
      - 굉장히 예쁜 주기적 패턴이 나옴
    - 현실적인 시그널
      - 세 가지 다른 축이 있음
      - 굉장히 노이즈한 범피한 시그널이 나옴
  - 그렇기에 현실적인 시그널의 세 가지 방향의 시그널을 한 가지 방향으로 합치는 과정을 우선 거치고 노이즈를 없애는 과정을 거치면 이상적인 시그널에 가까운 시그널을 얻을 수 있음
  - step 1 : 한 축 방향으로 시그널 바꾸는 과정
    - 세 축 방향의 가속 시그널을 한 축으로 바꾸는 방법
      - 가장 쉽게는 Y축 방향의 시그널을 선택하면 됨
      - 그 이유는 방향의 가속이 제일 크게 나타나기 때문
    - 발생하는 문제
      - 사람이 전화기를 수직 방향으로만 가지고 있다라는 보장이 었음. 전화기가 가방에 놓여있을 수도 있고 옆으로 놓여있을 수도 있고 어떻게 놓여있을 지를 모름
      - 한 축 방향의 데이터를 선택적으로 사용하는 것은 위험한 생각
      - 제일 큰 가속이 어떤 특정 방향으로 나타나고 이 가속도계가 세 축으로 나눠서 센싱을 하고 있다고 가정, 세 축 방향의 가속을 모두 합쳐서 한 쪽 방향의 가장 큰 가속을 인식해내는 방식으로 가속도를 한 축 방향으로 만들 수 있음
      - 좀 더 테크니컬한 텀 : X Y Z 방향의 가속을 (x^2+y^2+z^2)^(1/2) 식을 활용해서 한 축 방향의 가속으로 합침. 이렇게 합치면 조금 더 안정적인 시그널을 볼 수 있음
  - step 2 : 노이즈를 리무브하는 과정. 
    - 문제
      - 한 스텝당 한 번의 픽이 나타나는 패턴은 나타나지 않음. 한 스텝당 여전히 여러 번의 피크가 존재하게 됨.
      - 노이즈 때문에 걷지 않은 순간에도 피크가 나타날 수 있음
      - ex. 걷는 동안 전화기가 다리에 붙어 있는 게 아니라 소규모로 계속 조금씩 흔들리게 됨. 여기서 조금씩 튀는 피크가 나타나게 됨.
      - ex. 어떤 사람들은 걸을 때 한 걸음씩 깔끔하게 걷지 않고 약간씩 바운스가 있는 경우가 있음. 이런경우에도 픽이 나타나게 됨.
      - ex. 사용자가 전화기를 쓰면서 걸을 수도 있고 터치를 할 때마다 전화기가 조금씩 흔들릴 수 있고 다릴 떨 수도 있는 등 이런 경우 피크가 나타나게 될 수 있음
    - 노이즈 없애는 테크닉
      - 센서 데이터를 전처리 과정을 통해 노이즈 없애는 것은 머신러닝 기술을 활용하기 전에 항상 해야 되는 일
      - 무빙 에버리지
        - 센서 데이터 한 포인트만 보면 너무 민감한 데이터이기에 각각의 데이터를 쓰는 게 아니라 주변의 여럳 ㅔ이터를 묶어서 평균값을 데이터로 활용
        - 특정 윈도우 사이즈의 데이터를 모아서 그것의 에버리징 값을 현재의 센서값으로 사용하자. 그러면 센서의 튀는 부분이나 민감하게 잘못센싱된 값들이 없이지지 않을까가 핵심 아이디어 
        - 무빙 윈도우를 적용할 때 조심해야 할 부분은 윈도우 사이즈 정하는 것. 
          - 윈도우 사이즈를 짧게 정하면 에버리징 효과가 크게 나타나지 않음
          - 무빙 윈도우를 크게 정하면 필터링 된 데이터가 굉장히 깨끗하게 나오는데 너무 큰 윈도우를 적용하게 되면 시그널 안에 있는 정보가 다 뭉개져서 없어지게 됨
          - 고로 윈도우 사이즈를 탐지하고자 하는 정보의 양과 얼마만큼 많이 스무딩하고자 하는가를 동시에 고려해서 잘 정해야함
      - Exponential Smoothing
        - 기존의 무빙 에버리지 방식이 데이터를 여러 개 모아 에버리징 하는 방식이라면 익스포넨셜 스무딩은 다른 방식으로 데이터를 요약해보자가 핵심 아이디어
        - 무빙 에버리지는 과거의 값이나 현재의 값을 똑같이 웨이트를 줘서 에버리지하게 됨. 익스포넨셜 스무딩은 과거의 값들도 반영하고 싶은데 현재의 값에 더 큰 웨이트를 주고 싶다 하는 경우에 활용.
        - 재귀적으로 정의
        - X의 값에 α만큼 rate를 주고 기존의 필터링된 값에 1-α 만큼의 weights를 주는 식으로 재귀적으로 정의하게 되면 α가 0.7일 때 현재 값의 70% weights가 가게 되고 기존의 요약했던 값의 30% weights이기 때문에 이것을 진행하면 과거의 값에 대하 ㄴ효과가 기하급수적으로 떨어지는 효과 발생 
        - Raw Acceleration Signal : 굉장히 피크도 많이 나타나고 지저분한 노이즈가 많이 낀 걸 볼 수 있음
        - Signal with Exponential Smoothing (α = 1/6) : 피크가 좀 더 잘 하이라이트되는 시그널이 나옴 
        - 문제
          - Raw Acceleration Signal 은 피크가 빠르게 나타나는 부분에서 나타나는 특성ㅇ르 가지는 시그널. 여기에 exponential smoothing을 적용하게 되면 피크가 원래 시그널에 비해 굉장히 낮게 나오게 됨. 이 피크가 나오는 데 있어 피크가 일정 시간 뒤에 나타나는 지연현상이 나타나게 됨
        - 극복방안
          - Median Filtering : 윈도우를 적용해 요약값 쓰는 아이디어
            - 윈도우에 있는 값들이 median을 뽑아 그 값을 활용
            - 이 값을 활용하면 익스포넨셜 스무딩에서 보는 문제 해결. 피크도 원시그널과 굉장히 비슷하게 나오가 되고 지연현상도 나타나지 않는 것을 볼 수 있음
  - step 3 : 그럼 이상적인 신호에 가까운 신호가 나와서 그거를 가지고 피크 수를 세고 스텝을 셀 수 있음
    - 삼축 데이터를 한 축으로 바꾸고 타임도메인 필터를 적용하거나 프리퀀시 도메인 필터를 적용해서 노이즈들을 제거하는 스텝까지 다 거치고 나면 이상적인 시그널에 가까운 시그널 얻을 수 있음
    - 이 피크들을 탐지하면됨
    - 피크를 탐지하는 알고리즘
      - 미분값이 positive에서 negative로 바뀌는 순간이 피크라고 보면됨
      - 피크가 나왔다고 해서 다 걸음에 해당하는 것이 아니기에 피크가 나오는 점을 확인하고 그 점의 앰플리튜드를 확인해서 이게 어떤 이상이 되면 피크다라고 보면 됨
- Frequency Domain Filtering
  - 시간축 상에서 윈도우를 정해 어떤 식으로든 대표값을 요약해서 그 값을 신호로 활용하자는 아이디어. 이것을 타임도메인에서 스무딩한다고 해서 차임도메인 스무딩이라 부름
  - 타임도메인 필터링이 적용하기 어려운 경우에 적용해볼 수 있는 필터링 기법 : 프리퀀시 도메인 필터링
  - Frequency Domain Filtering 핵심 아이디어 : 모든 종류의 시그널은 sine waves의 weighted sum으로 되어 있다는 것.  여러가지 서로 다른 주기와 진폭을 갖는 sine waves들의 sum으로 표현될 수 잇고 이는 수학적으로 증명 됐기에 이 타임도메인 시그널을 프리퀀시 도메인의 시그널로 변경한 다음에 도미넌트한 프리퀀시를 가지는 시그널만을 뽑아내가지고 그 정보만 활용하고 나머지 프리퀀시에 있는 정보는 빼버리기. 이것을 다시 타임도메인으로 갖고 오면 sine waves 컴포넌트만 남아 예쁜 시그널을 볼 수 있음
  - Frequency Domain Filters에도 굉장히 여러 가지의 필터가 존재
    - low-pass filter : 낮은 프리퀀시만 필터링
    - highpass filter : 높은 프리퀀시만 필터링
    - bandpass filter : 어떤 프리퀀시부터 어떤 프리퀀시까지 보고싶다라고 했을 때 필터링
      - 사람의 보이슬 ㄹ가지고 뭔가 탐지하겠다 할 때 사람보이스가 가지는 프리퀀시의 대역이 있기에 이 대역 외에 나머지 대역의 소리를 잘라버리고 인지하는게 좋음. 이럴 때 밴드패스 필터 적용
    - notch filter : 신호에서 특정 프리퀀시만 뺼 수 있는 형태의 필터

