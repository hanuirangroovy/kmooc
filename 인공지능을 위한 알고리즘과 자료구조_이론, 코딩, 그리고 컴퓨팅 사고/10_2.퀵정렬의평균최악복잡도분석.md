# 10. 힙 정렬과 퀵 정렬

## 10-2. 퀵 정렬의 평균/최악 복잡도 분석

- 퀵 정렬
  - 거의 in-place에 가깝고 힙정렬보다 속도가 빠른 장점이 있음(평균적으로)
  - 평균 time complexity : Θ(nlg(n))
  - 최악의 경우 time complexity : Θ(n^2)
- 전략
  - merge sort 
    - array를 반반씩 나눠서 divide and conquer로 접근
    - middle point는 first와 last의 가운데 지점, 여기를 잘라서 거기를 기준으로 array를 왼쪽, 오른쪽 이렇게 위치를 기반으로 array를 나눔
  - quick sort 
    - array를 나눠서 dividie and conquer로 접근하는 것은 같으나 quick sort의 경우 array를 빈으로 나누는 게 어떤 특정 location
    - 어떤 특정 값보다 작은 숫자들, 그리고 큰 숫자들을 기준으로 양쪽 array를 나눔
- Run-time Analysis
  - merge sort와 마찬가지로 quick sort에서도 현실적인 방법을 채택해서 array size가 굉장히 작으면 insert sort 수행해서 더 이상 recursion을 하지 않는 방법 채택
  - best case Scenario
    - merge sort에서 한 것처럼 피벗을 잘 골라서 반반씩 나눌 수 있는 피봇, 즉 어떤 피봇을 고를 때마다 median 중간값을 고를 수 있다고 하면 merge sort와 같은 complexity 가짐
  - worst case Scenario
    - time complexity가 피벗을 골라서 파티션을 할 때마다 하나씩 제자리를 찾아가게 됨
    - run time : T(n) = T(n-1) + Θ(n) = Θ(n^2)
    - 정렬문제를 푸는 도중에 median을 찾는 것은 어려운 일! 그래서 대안으로 정해진 숫자의 elements를 샘플링해서 그 가운데 median을 찾으면 전체의 median과 그나마 좀 비슷하지 않겠냐라는 접근법을 취할 수 있음. 최악의 경우를 피할 수 있는 것은 아니지만 실험적으로 rpactical하고 했을떄는 그나마 median에 가까운 값을 찾을 수 있음.
- Median of Three
  - 주어진 array에서 첫 번째 그리고 마지막 그리고 가운데 위치에서 3개를 뽑아서 그 3개 중에  가운데 값.
- Implementation
  - Median of Three로 하면 merge sort와 마찬가지로 array를 파티셔닝하기 위해서 array와 같은 사이즈의 arry가 추가적으로 필요하기 됨. 그렇게 되면 quick sort가 in-place에 가깝다고 얘기할 수 없음.

