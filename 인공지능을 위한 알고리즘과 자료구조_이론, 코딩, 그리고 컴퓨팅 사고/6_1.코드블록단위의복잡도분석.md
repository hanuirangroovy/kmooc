# 6. 알고리즘 복잡도 분석

# 6-1. 코드 블록 단위의 복잡도 분석

- 알고리즘 분석의 목표
  - 코드블락
  - C++코드 일수도 있고 수도코드(의사코드라고 불리는)를 가져와서 asymptotic하게 n이 커졌을 때, 어떤  n에 대해 asymptotic 런타임과 asymptotic memory requirement 문제의 크기를 설명하는 variable, n이던 vertex의 개수이던 엣지의 개수이던 이런 파라미터들로 표현하는 것이 알고리즘 분석의 첫 번째 단계
  - 예시 : n 사이즈의 어레이가 있을 때 merge sort같은 경우에 nlgn의 시간을 요구하고 그 다음에 n에 비례하는 메모리를 요구하는 것들을 도출해내는 과정
- Motivation
  - 알고리즘의 asymptotic behavior는 알고리즘 n이 커졌을 때 문제의 사이즈가 커졌을 때 어떻게 행동하는지 과연 이 알고리즘이 n이 아주 큰 상황에서도 잘동작할 것인지를 알아보는데 중요한 정보를 제공
  - 예시 : 알고리즘 A가 있고 complexity가 Θ(n^2), 알고리즘B가 있고 이 알고리즘이 요구하는 계산량이 nlgn이라고 할 때 간단하게 n이 2k라고 할 때,  A알고리즘은 4k^2만큼의 계산량을 요구하게 되고 B알고리즘은 2klgk+2k 정도를 소비. n을 5배로 키워서 n이 10k가 됐을 때, A알고리즘은 n이 100k^2이 되는데, 즉 문제사이즈를 5배 증가시켰을 때 요구되는 시간은 5배의 제곱인 25배가 된 것. B알고리즘은 5배 증가
  - A알고리즘은 n이 커지면 커질수록 점점더 많은 계산량을 필요로 하겠구나 생각
  - 알고리즘의 asymptotic behavior라는 것은 n이 증가했을 때, 과연 이 알고리즘이 요구하는 런타임이 얼마나 증가하게 되는것인가를 기반으로 하는 것
  - 만약 큰 n에 대해 동작해야된다고 하면 compliexity 복잡도를 낮추려는 노력 필요
  - lgn의 경우 lgn의 complexity를 가지는데 n을 두배증가시켜도 계산량은 1만큼 증가
  - 바이너리 서치를 생각해볼때 정렬된 어레이에서 가운데 값과 찾고있는 값을 비교해서 만약 찾고 있는 값이 가운데 것보다 더 크다고 하면 가운데 값보다 작은 모든 값들은 검색대상에서 제외되기에  단 한번의 스텝으로 전체의 절반을 제외시킬 수 있음. 그래서 문제사이즈를 2배 증가시켜도 서치에 필요한 계산량은 단 하나만 증가 
- Machine Instructions
  - CPU, GPU 계산하는 프로세서들은 모든 계산을 다 할 수 있는 것은 아니고 굉장히 한정된 숫자의 오퍼레이션들만 수행할 수 있음
  - 더하기, 빼기, 곱하기, 나누기 등등 A, B중에 뭐가 더 큰지 계산한다던지 이런것들을 연산할 수 있는데 이렇게 정해진 연산들을 인스트럭션이라고 부름
  - 인스트럭션 셋 : 인스트럭션들을 모아놓은 것. 이 인스트럭션 셋은 CPU나 GPU나 이런 프로세서에 따라서 전혀 다름
  - 프로그램을 컴파일한다 : 컴파일 한 다음에 머신이 수행할 수 있는 인스트럭션 레벨로 표현하겠다는 의미. 컴파일을 할 때는 타겟을 정해놓음. 코드로 짠 것을 머신 랭귀지로 translation하는 과정에서 타겟을 정해줌
  - ARM 용으로 컴파일해서 x86에서 실행시키면 동작X.그 이유는 인스트럭션 셋이 다르기 때문. 그래서 특정한 인스트럭션은 어떤 특정 CPU에서 정확하게 몇 번의 사이클에 수행되는지 정해져 있음.
  - 어떤 프로그램이 정확히 어떤 인스트럭션으로 이루어져있다는 것을 앎녀 우리 프로그램이 얼마만큼의 시간을 소비할 것인지 계산할 수 있음
  - 정확한 계산이라고 하기 힘든 이유는 캐시가 되게 큰 역할을 하는데 데이터를 계산하기 위해서 CPU나 프로세서를 안으로 가져와야 하지만 만약에 이미 가져와 있는 데이터에 대해 연산을 할때는 굉장히 빠르지만 데이터를 메모리에서 가져오는 것, 즉 램에 있는 것을 CPU의 캐시에 가져오는데 굉장히 많은 CPU사이클이 필요. 그래서 정확하게 몇 사이클, 몇 초 걸릴거다 예측하는 것은 상당히 어렵고 대충 예측만 가능 
  - 인스트럭션 예시 : 0x06870000000F. 기계한테 프로세서한터 어떤 연산을 해야하며 어떤 데이터들 사이에서 연산을 수행해라 이런 것의 조합으로 이루어짐
  - 인스트럭션 형태를 사람이 조금아니마 이해할 수 있는 형태로 변환해 놓은 것 : 어셈블리 랭귀지
  - 요즘에 사용하는 랭귀지는 좀 더 하이레벨 랭기지. MATLAB, JAVA, C#, C++, Python 이런 것들을 하이레벨 랭귀지라 부름.
  - 하이레벨 랭귀지는 더 좋다가 아니라 얼마나 사람에 가까우냐. 사람이 이해하기에 좋냐라는 게 기준점
  - 인스트럭션 이나 어셈블리 랭귀지는 고이장히 로우레벨 랭귀지
  - C프로그래밍 랭귀지는 미드레벨 랭귀지. 예를 들어 포인터 같은 거로 메모리를 바로 엑세스할 수 있음
- Operators
  - 프로그램이 랭귀지에 있는 일반적인 오퍼레이션들. 어떤 특정갑승ㄹ 엑세스한다던지 어떤 variable에 특정값을 assign한다던지, 더하기 뺴기 곱하기 나누기 등등의 연산을 한다던지.  메모리 allocation을 한다던지. 이런 오퍼레이션들은 constant타임에 수행될 수 있음. 알고리즘을 분석할 때 사칙연산 등등의 오퍼레이션들을 다 constant타임에 수행될 수 있음.
  - 즉, 정해진 어떤 fixed number of cycle에 수행될 수 있음. 그 이유는 다 머신 인스트럭션에 매핑되기 때문
  - 이 인스트럭션에 매핑될수 있는것들은 다 fixed number of cycle. 정해진 숫자의 사이클안에 수행될 수 있는 것이므로 리니어한 시간에 수행될 수 있음
  - 사실 메모리 allocation과 메모리 deallocation, new, delete 혹은 C에서는 malloc, free 이런 오퍼레이션들은 사실은 더하기, 빼기 이런 간단한 것들에 비해서 훨씬 느림
  - 느린 이유는 메모리를 할당받으려고 할 때, OS랑 windows나 linux랑 커뮤니케이션을 해야하기에 확인을 하고 주고 이런과정들 때문에 간단한 연산대비 100배씩 느린 경우가 있음. 그럼에도 불구하고 single CPU 인스트럭션에 수행가능한 부분이기에 constant time으로 취급
  - object oriented language에서 클래스를 사용하게 되면. 클래스의 new 오퍼레이터를 돌릴 때, 생성자 파괴자, constructor, destructor이런 것들을 호출하게 되는데 이 안에서 뭔가 하는 것에 대한 시간은 빠져 있는 것
  -  단순히 메모리만 allocation하고 constructor에서 뭘 할지 모르기에 그것은 배제하고 단순히 메모리만 받아오는 것이 constant 타임에 가능
  - 그래서 하나하나의 오퍼레이션들이 constant 타임에 이루어지기 때문에 우리가 이 constant 타임에 이루어질수 있는 오퍼레이션들이 연속으로 있음.
- Blocks of Operations
  - 10줄 5줄 있는 상황에도 이 전체의 코드 block이 다 constant 타임에 수행될 수 있다고 얘기함. 예를들면 A와B를 스왑하는게 일반적으로 이렇게 3줄의 코드로 이루어지고. 3줄의 코드 각각이 다 constant 타임이기 때문에 이 3줄다 합해서 constant 타임에 가능하다고 이야기.
  - AVL트리에서 트리를 돌리는 굉장히 복잡한 오퍼레이션들이 있는데 자세히 보면 다 assignment. 다 constant 타임에 수행가능한 코드라인들이고 이것들이 모였다고 해도 결국 constant타임에 수행될 수 있음.
- Block in Sequence
  - 시퀀스가 블락으로 주어졌을 때 만약 3블락이 있는데 각각이 constant, quadratic, linear 이렇게 있으면 이중에 제일 큰 것을 기준으로 이야기. 큰 게 dominant하다고 함

