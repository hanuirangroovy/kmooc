# 5. 함수의 점근적 분석

# 5-1. 함수의 점근적 분석법

#알고리즘분석 #점근적분석법 #AsymptoticAnalysis



## Asymptotic Analysis

- 점근적인 분석법
  - 예를 들어 sorting problem에서 숫자의 개수가 문제의 크기라고 할 수 있음. 이러한 문제의 크기가 아주 크게 증가했을 때 우리가 갖고 있는 알고리즘은 얼마만큼의 계산량을 요구하는가 -> 점근적으로 큰 숫자에 대해 분석하기에 asymptotic analysis라 이름 지어짐 
- Background
  - 우리가 서로 다른 2개의 알고리즘을 갖고 있다고 했을 때 같은 문제를 푸는 2개의 알고리즘이 있을 때 컴퓨터 사이언티스트로써 어떤 알고리즘이 다른 것보다 더 좋은지에 대해 좀 더 과학적이고 수치적으로 표현할 수 있게 하기 위해 asymptotic analysis를 다루게 됨
  - 두 알고리즘이 있다고 할 때, 두 개를 비교하는 가장 간단한 방법은 둘 다 코딩하는 것 -> 둘 다 프로그램 짠 후 테스트케이스를 주고 과연 몇 초걸리는 지, 메모리를 얼마나 소비하는지 측정 후 비교
    - 최선의 방법인가? 기본적으로 프로그래머들이 비쌈. 프로그래밍 시킬려면 돈을 많이 줘야되기 때문에 두 알고리즘을 비교하기 위해 구현까지 한다는 것은 비용적으로 비싼 일이며 사람이 하는 일이기에 오류가 발생할 가능성이 있음(어떤 사람은 좀 더 빠른 성능이 나올 수 있고 어떤 사람은 에러가 발생할 수 있는 여지 있음).
  - 우리가 추구하는 것은 주어진 알고리즘을 수학적으로 분석해서 과연 두 알고리즘 중에 뭐가 더 좋더라는 결론을 내리고자 하는 것
- Asymptotic Analysis
  - 일반적으로 알고리즘을 분석하는데, 이 알고리즘의 런타임, 메모리 요구량 등 어떤 variable을 통해 표현
  - varoable 예시
    - 어떤 어레이에서 몇 개의 elememt가 있는지 보통 n이라 표현하는 몇 개에서. n이 vairable
    - n by n 매트릭스가 있다고 할 때 문제의 사이즈 역시 n이라는 variable로 표현
  - 알고리즘이나 문제에 따라서 variable이 단순히 n 하나만 있는 게 아니라 k, m 등 서로 다른 몇 개의 varialbe 들의 조합으로 나타날 수 있음
  - n 하나가 있는 경우 어레이 사이즈가 n개의 element로 이루어져 있을 때 sorting하는데 드는 복잡도,  어떤 그래프가 2개의 variable vertex 개수, 엣지 개수로 표현될 때, 어떤 shortest path를 구한다고 했을 때 알고리즈이 요구하는 계산량이 v와 e로 어떻게 표현되는지 등을 다룸
- Linear and Binary Search
  - Linear search  : 어레이의 특정한 값을 찾고자 할 때 앞에서부터 순차적으로 하나씩하나씩 테스트하는 것
  - Binary search : 어레이가 sorting 되어 있을 때 순서가 non-decreasing order로 정렬이 되어 있을때만 적용할 수 있는 방법. 중간값과 찾고자 하는 값을 비교해서 중간값보다 찾고자하는 값이 작으면 오른쪽 부분은 날려버리고 왼쪽 부분에서만 검색하고  마찬가지로 왼쪽 서브 어레이에서 중간값과 찾고자하는 값을 비교해서 대소관계에 따라 반대편 반은 검색에서 제외할 수 있는. 반씩 나눠지는 검색 방법
  - 어레이사이즈 n이 커질 때 과연 몇 번의 비교를 수행해야 찾고자하는 특정값을 찾을 수 있을까를 그래프로 나타낸다면 x축은 n(어레이 사이즈), y축은 실제로 몇 번의 비교연산을 수행해야되냐
    - Linear search : n이 커지면서 선형적으로 증가
    - Binary search : n이 증가해도 비교횟수의 증가폭은 굉장히 낮음  
    - Linear search보다 Binary search가 더 효율적인 알고리즘이다
    - but Binary search는 어레이가 sorting되어 있을 때만 사용 가능
  -  asymptotic analysis과정은 알고리즘이 주어졌을 때. 우리가 무엇을 이 알고리즘의 성능을 테스트하는 지표로 삼을 것인가를 먼저 선택해야함
  - 어떤 특정 element를 서치하는 알고리즘에서는 몇 번의 비교연산이 수행되었는가가 알고리즘의 계산량을 표현하는데 중요한 variable이 될 수 있음. 뿐만 아니라 그 알고리즘 자체도 중요하지만 이것에 연관된 데이터 스트럭쳐도 상당히 중요하기에 알고리즘과 데이터 스트럭쳐의 관계성을 고려해서 이 asymptotic analysis를 수행해야 됨.
  - 무엇보다 중요한 것은 이 asymptotic analysis는 우리가 이 알고리즘을 어떤 컴퓨터, 어떤 머신에서 구동시키는가와 전혀 독립적으로 수학적으로만 이루어져야 한다는 특징이 있음
- Quadratic Growth, 이차함수의 증가
  - f(n) = n^2
  - g(n)  = n^2 + 3n + 2
  - 두 그래프는 0~3 범위에서는 차이가 나지만 0-1000 범위에서는 거의 구분할 수 없을 정도의 차이. 이들의 차이를 리미트를 취해 가지고 n이 무한대로 커졌을 때는 상대적 비율의 차이는 0에 수렴
  - symptotic analysis의 핵심은 n이 무한대로 커졌을 때, problem 사이즈가 무한히 커졌을 때 두 알고리즘은 얼마나 차이가 나는가
- Polynomial Growth
  - 비교하는 횟수를 n으로 표현했을 때 두 알고리즘이 굉장히 다르더라도 결국에 제일 중요한 것은 가장 차수가 높은 항, leading term이라고 하는 가장 차수가 높은 항이 제일 중요하다는 결론
  - coefficient는 리미트를 취해서 n을 무한대로 키웠을 때도 여전히 남아있음
- Counting Instructions
  - 어떤 알고리즘의 number of comparision, 비교횟수 뿐만 아니라 프로그램을 실행했을 때, 알고리즘을 실행했을 때의 number of instruction, CPU에서 동작하는 가장 기본적인 실행의 단위가 instruction인데 number of instruction을 셀 수 있다고 했을 때 두 알고리즘이 누가 더 뛰어나다는 얘기를 할 수 있을만큼 차이가 있을까
  - 알고리즘이 요구하는 instruction의 개수를 셀 수 있다고하면 컴퓨터의 CPU속도를 알고 있기 때문에 이 알고리즘이 과연 몇초의 시간을 소비할것인가를 예측해볼수 있음.  만약에 우리가 1GHz 컴퓨터가 있다고 했을 때 1GHz의 컴퓨터는 1초에 1 million 개, 즉 백만개의 instruction을 수행할 수 있음
  - 알고리즘 A가 f(n)만큼의 instruction 실행회수를 요구하고 B알고리즘이 g(n)만큼을 요구한다고 했을 때, 이 상태에서는 만약에 f(n)이 더 커서 g(n)쪽이 더 효율적인 알고리즘이라고 하더라도 만약에 A 알고리즘을 구동시키는 컴퓨터가 M배로 빠른 컴퓨터를 구매해서 f(n)에 해당하는 알고리즘을 구동시키게 되면 둘의 속도차이는 뒤집힐 수  있음
  - 즉 asymptotic analysis를 할때에는 두 알고리즘이 이런 polynomial 로 표현될 때, 앞에 있는 계수부분은 더 비싸고 더 빠른 컴퓨터로 커버할 수 있음
  - 하지만 두 알고리즘이  애초에 승수가 다르면 f(n)은 an^2이고 g(n)은 bnlgn이라고 했을 때. 이 둘은 절대 따라잡을 수 없는 차이가 남. 더 빠른 컴퓨터를 구매하는 것으로는 차이를 극복할 수 없음
- Weak Ordering
  - 두 함수가 주어졌을 때, 두 함수는 각각 A알고리즘, B알고리즘의 요구하는 instruction 횟수를 나타냄. 만약 두 비율이 f(n)/g(n), 이 비율을 n을 무한대로 증가시켰을 때 어떤 constant 에 수렴한다고 하면 이 두 function, 두 알고리즘은 비슷한 복잡도를 가지고 있다고 얘기함
  - 0 이상이고 무한대 미만의 어떤 특정한 값에 수렴된다고 했을 때 이 두 함수는 동일한 복잡도를 가지고 있다고 해서 물결표시로 표현
  - 만약에 이 비율이 에 수렴한다고 했을 때는 g(n)이 분모에 있기 때문에 g(n)이 더 큼. 이럴 때는 g(n)이 더 크다는 부등호 방향으로.
  -  ordering을 하는데. n^2과 2n^2은 같은 동일선상에 놓고 굳이 이 둘의 대소관계를 구분하지 않기 때문에 weak ordering이라는 표현을 쓰는 것
  -  f(n), g(n)이 두 알고리즘의 런타임을 얘기하고 있다고 했을 때 f(n)과 g(n)이 equivalent, 즉 동일선상에 있다고 했을때는 더 비싼 더 빠른 컴퓨터를 구매하면 그 둘의 격차는 충분히 뒤집힐 수도 있는 경우를 얘기하고 반대로 어떤하나가 다른 하나보다 더 크다, order가 더 크다라고 얘기하는 것은 우리가 단순히 더 비싼, 빠른컴퓨터를 실험에 사용함으로써 그 둘의 대소관계를 뒤집을 수 없다는 이야기. 즉 이런 경우에는 한 쪽 알고리즘이 더 효율적인 알고리즘이라고 얘기할 수 있음.