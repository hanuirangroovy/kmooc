# 6. 알고리즘 복잡도 분석

# 6-1. 코드 블록 단위의 복잡도 분석

- control statements
  - if문으로 얘기하는 condition

  - if문 안에 컨디션이 들어가고 true일 때는 if절에 붙어있는 statement를 수행하고 아닌 경우에는 컨디션이 false, 틀렸다고 하면, else에 들어가 있는 것을 수행

  - conditional statement는 컴플렉시티가 크게 두가지로 나뉨

    - 첫 번째. 컨디션을 테스트하는 컴플렉시티
    - 두 번째. 테스트 결과에 따라서 어디를 수행할 때에 발생하는 컴플렉시티.
    - 일반적으로는 컨디션을 테스트하는 컴플렉시티는 constant 타임으로 생각
    - 안에 들어가는 n이 5보다 크냐. 짝수냐 홀수냐 이런 간단한 연산들이 일반적이기 때문에 많은 경우에는 컨디션이 constant타임이지만 if문안에서 function call을 한다던지하면 constant에 끝나지 않음. 이런 control statement를 봤을 때 factorial 함수를 보면 n이 0일 때는 return 1을 하고 아닌 경우에는 recursive하게 call을 하게 되는데 이런 경우에 어떤 것이 실행될지 알 수 있어서 컴플렉시티 계산에 도움이 됨

  - Analysis of Statements

    - element가 지금까지의 최대값보다 클 때 오퍼레이션이 일어남. 이런 경우에는 assignment 빨간색 부분이 몇 번 실행될건가는 데이트를 보기 전에는 알 수 없음
    - 만약 어레이가 정렬되어있어서 작은 것부터 큰 것 순서대로 되어 있으면 빨간색 문구는 항상 최대값이 갱신되기 때문에 항상 실행됨
    - 만약 어레이가 작은 순서로 역순으로 작아지는 순서로 정렬이 되어 있다고 하면 이미 최대값이 max에 들어있기 때문에 한번도 실행되지 않음
    - 이와 같이 데이터의 분포에 따라서 시행횟수가 달라지는 경우가 있기 때문에 어떤경우에는 정확하게 이것을 알아내기 힘듦
    - 이럴 때 할 수 있는 두 가지
      - 최악의 경우에 이게 몇 번 동작할까. 이 알고리즘은 최악의 경우 모든 데이터에 대해 한 번씩 수행된다는 것을 얘기할 수 있음
      - 평균적으로 일반적인 데이터가 주어졌을 때 데이터가 랜덤으로 분포되어 있을 때 몇 번일까에 대해 얘기할 수 있음

  - Condition-controlled Loops

    - 반복문. 
    - for, while문을 쓸 수 있는데 for문을 initialize 하는 것, 컨디션을 체크하는 것, increment 하는 것. 
    - i가 n보다 작은지 테스트하는 게 컨디션
    - i를 하나씩 증가시켜주는 게 increment
    - 이 각각이 다 constant차임에 가능
    - for문이 i가 0부터 n까지 반복되는 구조가 있다고 했을 때 만약에 가운데 break나 return같은 loop를 빠져 나오는 statement가 없다고 하면 런타임은 Ω(n)이 됨. 즉, 컴플렉시티는 n번 반복을 하기에 최소한 n이 소비된다는 얘기
    - 어떤 반복문이 있는데 반복문 안에서 어떤 코드들이 Θ(n)만큼의 컴플렉시티를 가진다고 하면 반복문 전체의 컴플렉시티는 f(n)에 해당하는 부분이 n번 반복되기 때문에 최종적으로 Θ(nf(n))만큼 만큼 컴플렉시티가 소비된다고 할 수 있음

  - Analysis of Repetition Statements

    - 오퍼레이션의 예제로는 사이즈 m인 어레이에서 특정 값 찾기
      - 특정값이 있느냐 없느냐로 찾는데 O로 표현되는 이유는 두 번째 아이템이 찾는 겂이라서 끝날 수 있기에 서치의 최악의 경우의 큼플렉시티는 m개를 다 보는 거지만 실제로는 빨리 끝날 수 있기에 빅오 노테이션을 쓰는 것
      - 이런 경우에 컴플렉시티는 밖에 있는 루프는 O(nm), 안에 있는 루프는 O(m)
      - 안에 있는 코드가 이 루프를 컨트롤하는 variable인 i에 종속적일 수 있는데 i에 대한 루프이고 그 다음 전체 몇 번의 연산이 일어나는지를 시그마를 통해 표현할 수 있음

  - Control Statements

    - 또 다른 하나의 예제인 control statement인 switch/cas 문
    - switch/case문은 i의 값을 보고 i의 값이 1, 2, 3, 4, 5 혹은 그 외에 따른 것일 때 특정 오퍼레이션들을 수행하는 것
    - switch는 값이 if문 같은 경우에 i가 x랑 같는지 i가 y랑 같은지 i가 n이랑 같은지 이런 것들을 if문으로 처리할 수 있음. 
    - switch/case 문 같은 경우에는 비교하는 대상이 반드시 컴파일시점에서 정해져 있는 값. 그래서 정해져 있는 constant한 값이랑만 비교할 수 있음. 그래서 case n 이런 것들은 불가능
    - switch/case문을 사용하게 되면 컴파일러가 미리 어디로 점프할지, 테스트하는 값이 들어오면 바로 해당 값에 해당하는 바이너리로 점프할 수 있도록 미리 최적화를 해놓음. 그래서 상대적으로 else if 에 비해 switch/case문이 정해져 있는 케이스에 대해서는 조금 더 빠를 수 있음

  - Serial Statements

    - 어떤 n개의 값이 있는 랜덤 리스트가 있고 제일 큰 값을 찾는 경우 혹은 뭔가 랜덤리스트가 있는데 특정 값이 있는지 보는 경우 무러써야 두 알고리즘의 컴플렉시티를 표현하는데 좋을것인가에 대한 이야기

    - 첫 번째, 제일 큰 값을 찾을 때 어레이가 랜덤으로 분포되어 있기에 어디가 큰 값인지 몰라 모든값을 다 한번씩 봐야함. 이것의 컴플렉시티는 Θ(n)

    - 두 번째, 특정값이 있는지 없는지 볼때는 특정값을 운이 좋아서 빨리 찾으면 빨리 끝나는 거. 

    - 만약에 어떤 부분은 Θ고 어떤부분은 O 이렇게 섞여있다고 할 때는 leading 첨 기준으로 나눔

      ex. 어떤 코드는 O(n). 어떤 코드는 Θ(n^2)이면 이면 n^2이 제일 큰 텀. 그러면 n^2에 해당하는 Θ(n^2)이 전체 컴플렉시티를 나타냄 

  - Functions

    - 계속 반복되는 오퍼레이션들을 수학적인 함수들을 포함해서 function 혹은 서브루틴이라고 얘기하는 코드로 따로 빼놓고 실행하기도 하고 어떤 클래스를 initialization한다거나 할 때 연결된 테스크들을 모아서 함수로 ㅁ나들어 놓기도 함
    - 단순히 function call에 해당하는 오버헤드는 constant 타임 취급
    - 함수 안에서 아무것도 하지 않더라도 이것의 컴플렉시티는 최소한 constant라고 얘기함
    - 함수 안에서 발생하는 런타임을 간단하게 T(N) 으로 표시. N은 함수가 받아들이는 파라미터의 사이즈

. 