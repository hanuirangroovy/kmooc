# 5. 함수의 점근적 분석

# 5-1. 심볼 기반 함수의 점근적 바운드

#점근적분석법 #심볼기반함수 #점근적 바운드 #세타 #빅오 #오메가

- 알고리즘의 asymptotic behavior, 알고리즘의 complexity 복잡도가 asymptotic하게 n이 증가했을 때 어떻게 행동하는지 어떤 양상을 띄는지를 표현할 수 있는 여러가지 notation을 배워보자
- 가장 흔히 사용하는 노테이션은 세타노테이션과 빅오노테이션
- 세타 노테이션은 사실 타이트 바운더리기 때문에 정확하게 알고리즘의 런타임을 얘기할 수 있음
- 빅오노테이션은 worst case complextiy를 얘기하기 때문에 worst case가 일반적으로 생각하는것이고 아무리 늦어도 시간안에는 답이 나오기에 실제로 유용





## Θ Notation

- 세타 노테이션은 f(n) = Θ(g(n))
- f(n)이라는 함수는 인스트럭션의 횟수라던지 런타임 등을 표현하는 함수
- f(n)을 기준으로 f(n)을 표현하고자 하는 대푯값 g(n)을 놓고 봤을 때, 다른 어떤 constant를 g(n)에 곱한게 있을 때 이 f(n)이 반드시 c1* g(n)과 c2* g(n) 사이에 샌드위치처럼 끼어있도록 하는 g(n)이 있다고 하면 f(n) = Θ(g(n))으로 표현
- 이렇게 돼야 하는 n의 범위는 어떤 특정한 n의 값. n0라고 표현되어 있는 n0보다 큰 모든 n에 대해서 c1, c2가 존재할 때, c1, c2가 f(n)을 샌드위치처럼 감싸는 형태가 되는 c1, c2가 존재
- 0 <= c1g(n) <= f(n) <= c2g(n)
- f(n)은 g(n)과 같은 속도의 증가속도를 가진다고 이야기함
- g(n)은 f(n)의 asymptotically tight bound. n이 쭉 점근적으로 커졌을 때, g(n)이 f(n)을 타이트하게 위아래로 바운드하고 있다고 이야기함



## O-Notation

- 빅오 노테이션은 세타 노테이션에서 위쪽만을 취하고 아래쪽은 제외한 노테이션
- f(n) = O(g(n))은 f(n)은 0보다 크지만 cg(n)보다는 작아야 함. 이것을 만족하는 constant c와 n0가 하나라도 존재하면 f(n) = O(g(n)).
- 0 <= f(n) <= cg(n)
- g(n)을 f(n)의 asymptotically upper bound라고 이야기함. 말그대로 f(n)보다 위에 있는 바운드라고 해서 upper bound라고 함. 당연히 f(n) = Θgn이면 세타는 upper, lower를 둘다 얘기하는 타이트한 바운드이기 때문에 당연히 f(n)은 Og(n)이라고 얘기해도 틀린 말이 아님. f(n) = Og(n)는 위에 upper 바운드를 덮어준 것이기 때문에 f(n)은 절대 cg(n)을 넘어가지 않음
- 이 알고리즘이 최악의 경우, worst case에도 g(n)을 넘어가지 않으는다고 알고리즘의 worst case 러닝타임을 얘기할 때 유용하게 사용



##  Ω Notation

- 빅오노테이션과 마찬가지로 한 쪽만 바운드 하는데 그 바운드가 아래쪽. 빅오는 위쪽을 바운드했다면 오메가 노테이션은 아래쪽을 바운드
- f(n) = Ω(g(n))이라고 하면 asymptotically lower bound. 그래서 이 알고리즘은 아무리 빨라도 이것보다는 느리다고 얘기할 때 주로 사용되는 텀
- best case 러닝타임을 이야기함



## 비교

- f(n) = Θ(g(n))라고 하면 오른쪽의 f(n)이  f(n) = O(g(n))이면서 동시에 f(n) = Ω(g(n))인 것과 동치
- if and only if 라고 하면 필요충분 조건. 그래서 양쪽이 필요충분관계
- f(n) = Θ(g(n)) if and only if f(n) = O(g(n)) 그리고  f(n) = Ω(g(n))



## o-notation

- 리틀오노테이션
-  f(n) = o(g(n))이라하면 어떤 positive constant n0가 있어야 하고 모든 constant c에 대해 f(n)이 cg(n)보다 작아야 함
- g(n)은 f(n)의 upper 바운드가 되고, asymptotically 타이트하지 않음 



## ω-notation

리틀오메가노테이션

- f(n) = ωg(n)라고 하면 모든 constant c에 대해서 저 위에 있는 f(n)이 g(n)보다 큰 식을 만족해야함



## 노테이션 특성

- transitivity
  - f(n) = Θ(g(n))이고 g(n) = Θ(h(n))이면 f(n) = Θ(h(n))
  - 이것은 o, O, ω, 그리고 Ω까지 다 동일한 내용
- reflexivity
  - f(n) = Θ(f(n))이라 할 때 빅오와 빅오메가에 동일하게 동작
- symmetry
  - f(n) = Θ(g(n))이라 할 때 반대로 g(n) = Θ(f(n))이라는 것. 그 이유는 타이트 바운드이기에
- tramspose symmetry
  - f(n) = Θ(g(n))이면 g(n)=Ω(g(n))이다. 리틀오, 리틀 오메가에서도 반대로 g(n), f(n)의 위치를 바꿨을 때 성립

- |        Θ(1)        |  constant   |
  | :----------------: | :---------: |
  |      Θ(lg(n))      | logarithmic |
  |        Θ(n)        |   linear    |
  |     Θ(nlg(n))      |  "n log n"  |
  |       Θ(n^2)       |  quadratic  |
  |       Θ(n^3)       |    cubic    |
  | 2^n, e^n, 4^n, ... | exponential |

  

- Algorithm Analysis

  - 우리가 소위 어떤 알고리즘의 런타임이 f(n) = O(g(n))라고 하면 d는 어떤 constant라고 했을 때, n^2, n^3, n^6 등등 뭔가 polynomial time complexity를 가진 알고리즘들을 우리가 일반적으로는 좀 효율적인 알고리즘의 그룹에 속한다고 이야기함
  - intractable : 어떤 문제들은 polynomial 알고리즘이 없다고 증명된 문제가 있고 polynomial 알고리즘이 알려주지 않은 문제가 있음
    - 대표적으로 traveling salesman problem 이라고 TSP문제라고 해서 모든 정점을 한번씩 거쳐서 시작점으로 돌아오는 최단경로를 구하는 문제
  - 지금까지 알려진 가장 좋은 방법은 (n) = Θ(n^2*2^n). exponential한 time complexity를 가지는 문제들도 있다고 할 수 있습니다.

  

## 용어정리

1. 점근적 분석(Asymptotic analysis)
   - e두 알고리즘을 수학적으로 비교해서 어떤 알고리즘이 더 효율적인지 분석하는 방법. 더 큰 order를 갖는 알고리즘은 더좋은 컴퓨터를 사용하더라도 대소관계를 뒤집을 수 없다.
2. Weak ordering
   - 문제의 크기를 무한히 증가시켰을 때, 두 알고리즘의 연산양의 비율이 상수에 수렴한다면 두 알고리즘 간의 대소관계를 구분하지 않는데
3. 세타, 빅오, 빅오메가 노테이션
   - 세타 노테이션은 알고리즘의 정확한 복잡도를 의미한다. 빅오 노테이션은 알고리즘의 상한을 의미하며 최약의 경우를 표현하기 좋다. 빅 오메가 노테이션은 알고리즈즘의 하한을 의미한다.
4. 리틀 노테이션 
   - 리틀 오, 리틀 오메가의 경우 빅오, 빅오메가 노테이션과 달리 점근적으로 타이트한 바운더리를 의미한다.



## QUIZ

1. O(1), O(N), O(NlgN), O(N!), O(2^N)  중 가장 비효율적인 알고리즘은?  O(N!) 
2. 알고리즘의 점근적 분석 관점에서 알고리즘 간의 order는 더 좋은 하드웨어를 통해 극복할 수 있다고 본다. (X)